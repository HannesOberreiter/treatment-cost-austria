---
title: "Treatment Cost in Austria"
author: "Hannes Oberreiter & Robert Brodschneider"
date: '2020'
github-repo: "https://github.com/HannesOberreiter/treatment-cost-austria"
output:
  bookdown::gitbook:
    config:
      fontsettings:
        theme: night
        family: sans
        size: 2
  bookdown::pdf_document2:
    keep_tex: true
header-includes:
- \usepackage{hyperref}
- \usepackage{float}
- \usepackage{caption}
- \captionsetup[figure]{font=small}
subtitle: University of Graz, Institut for Biology
bibliography: bib.bibtex
biblio-style: authoryear
link-citations: yes
urlcolor: blue
abstract: Summary of Stats and Statistics for Treatment Costs Varroa. Our Hypothesis
  is that the costs have an influence or correlated to the winter losses. H0 = Costs
  have no influence on survival rate, H1 = Costs have an influence on the survival
  rate.
---

```{r setup, include=FALSE, echo=FALSE}
knitr::opts_chunk$set(
  fig.pos   = "H", 
  out.extra = "", 
  fig.align = "center", 
  out.width = "100%",
  echo      = FALSE,
  include   = FALSE
  )

# Our Libraries
VLIBS <- c("tidyverse", "patchwork", "here", "readxl", "bookdown", "BlandAltmanLeh", "boot")

# Use Colors in Plots
# https://stackoverflow.com/questions/42458412/plotting-data-by-color-variable-with-ggplot2-in-r#comment72062654_42458412
colorBlindBlack8  <- c("#464343", "#E69F00", "#56B4E9", "#009E73", 
                       "#F0E442", "#0072B2", "#D55E00", "#CC79A7")

F_LoadLibs <- function(x){
  print(x)
  if(!require(x, character.only = TRUE)) install.packages(x); library(x, character.only = TRUE);
  return(T)
}
# https://stackoverflow.com/questions/62140483/how-to-interpret-dplyr-message-summarise-regrouping-output-by-x-override
options(dplyr.summarise.inform=F) 
# https://stackoverflow.com/questions/13286531/how-to-suppress-warnings-when-plotting-with-ggplot
options(warn=-1)


sapply(VLIBS, F_LoadLibs)
rm(VLIBS, F_LoadLibs)


#### Base Function and Data

# Beekeeper and Colonies in Austria based on 
# https://www.biene-oesterreich.at/daten-und-zahlen+2500++1000247
stats_aut <- tibble(
  year = c(2018, 2019),
  beekeeper = c(28432, 30237),
  colonies = c(373412, 390607)
)



# Bootstrap Functions for Median and Mean
fBootMedian <- function(d, i) {
  median(d[i])
}
fBootMean <- function(d, i) {
  mean(d[i])
}

```

```{r load-files, warning = FALSE}
source("partials/files.R", local = knitr::knit_global())

# Extract only answers with valid answer for costs
DATA <- RAW[!is.na(RAW$costs),]
```

# Cleanup

## No Treatment Answers

```{r}
# Extract No Treatment Answers
NO_TREATMENT <- DATA[DATA$varroa_treated != "Ja",]
NO_TREATMENT <- NO_TREATMENT[,c("id", "costs", "varroa_treated", "comments", "year", "T_amount", "c_short")]
DATA         <- DATA[!(DATA$id %in% NO_TREATMENT$id),]
```

In our survey `r nrow(NO_TREATMENT)` did answer "No Treatment against Varroa" and did give no answers for any treatment method, but included costs for varroa treatment. These `r nrow(NO_TREATMENT)` illogical entries were removed from our data analysis.

```{r}
rm(NO_TREATMENT)
```

## No Treatment Methods

```{r}
# Extract Participants which did answer costs but did give no answer on what treatment
NO_METHOD <- DATA[is.na(DATA$t_short),]
NO_METHOD <- NO_METHOD[,c("id", "costs", "varroa_treated", "comments", "year", "T_amount", "c_short")]
DATA      <- DATA[!(DATA$id %in% NO_METHOD$id),]
```

Because we want to analyze treatment methods in combination with the costs, we did also remove `r nrow(NO_METHOD)` participants which did answer treatment cost in the survey, but were not specific which methods they used. 

```{r}
rm(NO_METHOD)
```

## Zero Cost Answers

```{r}
# Entries with zero costs
COST_ZERO  <- DATA[DATA$costs == 0,]
COST_ZERO  <- COST_ZERO[,c("id", "id_original", "costs", "varroa_treated", "comments", "year", "T_amount", "c_short")]
# sponsorship (e.g. ImkereifÃ¶rderung, Gemeinde)
id_sponsor <- c(1672, 2003, 2446, 1930)
# biotechnical & hyperthermie
id_keep    <- c(2534)
id_remove  <- COST_ZERO$id[!(COST_ZERO$id %in% id_keep)]
DATA       <- DATA[!(DATA$id %in% id_remove),]
```

In total `r nrow(COST_ZERO)` participants said their treatment costs were zero. Only `r length(id_keep)` answers were kept, as the treatment was a combination of hyperthermia and biotechnical. We have no assumption. Ofcourse the equipment for the hyperthermia do costs something, but we don't know more details. `r length(id_remove)-length(id_sponsor)` were removed as they said zero costs but actually did treatment with organic acids. In addition `r length(id_sponsor)` participants got a sponsorship (eg from beekeeping club or local community) for their treatment costs, which were also removed from the cost analysis dataset.

```{r}
rm(COST_ZERO, id_sponsor, id_remove, id_keep)
```

## High Cost Answers

```{r}
csum <- summary(DATA$costs)
upper_limit <- csum[5] * 2
COST_UPPER <- DATA[DATA$costs > upper_limit & DATA$costs > DATA$t_estimated*2,]

COST_UPPER <- COST_UPPER[,c("id", "id_original", "hives_winter", "hives_lost", "costs", "t_estimated", "varroa_treated", "comments", "year", "T_amount", "c_short")]

# Remove these entries, as they make sense
id_nochange <- c(751)

COST_UPPER <- COST_UPPER %>% filter(!(id %in% id_nochange))

# Calculate new prices
COST_UPPER$new <- COST_UPPER$costs / COST_UPPER$hives_winter
DATA$costs[(DATA$id %in% COST_UPPER$id)] <- COST_UPPER$new
```

We defined upper limit cost outliner with 3rd quantile and multiplied by 10 which resulted in a cost limit of `r upper_limit`. In total `r nrow(COST_UPPER)` participants did answers above this limit. Upon investigating the `r nrow(COST_UPPER)` answers, we found out that most of them did answer a total cost and no cost by colony. Therefore, we divided the costs by the number of colonies going into winter. Only `r length(id_nochange)` participants were not changed, as one only had one colony and did hyperthermia treatment and the second one did explicit explain the high costs as comment.

```{r}
rm(id_nochange, upper_limit, COST_UPPER, csum)
```

# Standard Params

```{r calc-n, include=FALSE}
RAW_REPORTS <- RAW %>% group_by(year) %>% 
  summarize(
    n = n(),
    mean_colonies   = round(mean(hives_winter),2),
    median_colonies = median(hives_winter)
  )

DATA_REPORTS <- DATA %>% group_by(year) %>% 
  summarize(
    n = n(),
    mean_colonies   = round(mean(hives_winter),2),
    median_colonies = median(hives_winter)
  )

REPORTS <- tibble(
  Year    = RAW_REPORTS$year,
  Total   = RAW_REPORTS$n,
  Cost    = DATA_REPORTS$n,
  Percent = round(DATA_REPORTS$n/RAW_REPORTS$n*100,1)
)
rm(DATA_REPORTS, RAW_REPORTS)
```

The number of reports which did include costs and after cleanup of invalid or illogical answers was similar for the survey of 2018/19 with `r REPORTS$Percent[1]`% and for 2019/20 with `r REPORTS$Percent[2]`, see table \@ref(tab:reports).

```{r reports, include=T}
cn = c("Year", "Total [n]", "Answered [n]", "Percent [%]")
c = "Number of participants answering the question for estimated costs per colony in the survey two survey years."
knitr::kable(
  REPORTS,
  booktabs = TRUE, row.names = FALSE,
  col.names = cn, format = "markdown", caption = c
)
rm(REPORTS, cn)
```

## Data Distribution

The distribution of the costs looks right skewed, with some outliers into the extreme highs. The two survey years look comparable, see fig. \@ref(fig:distr-year).  

```{r distr-year, include=T, messages=F, warnings=F, fig.cap="Violin and overlapping boxplot of the costs from the survey, extreme outliers are not visible."}
stats_data <- DATA %>% 
  group_by(year) %>% 
  summarise(
    max    = format(round(max(costs),2), nsmall = 2),
    mean   = format(round(mean(costs),2), nsmall = 2),
    median = format(round(median(costs),2), nsmall = 2),
    min    = format(round(min(costs),2), nsmall = 2)
    )

text <- paste0(
  "Max.: ", stats_data$max, "\n",
  "Min.: ", stats_data$min, "\n",
  "Mean: ", stats_data$mean, "\n",
  "Median: ", stats_data$median, "\n"
  )

ggplot(DATA) +
  geom_violin(
    aes(x = year, y = costs), 
    fill=colorBlindBlack8[7],
    color=colorBlindBlack8[7]
    ) +
  geom_boxplot(
    aes(x = year, y = costs), 
    outlier.shape = NA, alpha=0.5, fill=colorBlindBlack8[5]
    ) +
  geom_segment(
    x = 1, y = 45,
    xend = 1, yend = 52,
    lineend = "round",
    linejoin = "round",
    size = 0.5, 
    arrow = arrow(length = unit(0.1, "inches"))
  ) + 
  xlab("") + ylab("Cost / Colony [Euro]") +
  geom_segment(
    x = 2, y = 45,
    xend = 2, yend = 52,
    lineend = "round",
    linejoin = "round",
    size = 0.5, 
    arrow = arrow(length = unit(0.1, "inches"))
  ) + 
  annotate(
    "text",
    label = text,
    x = c(1.35, 2.35), y = c(40, 40),
    hjust = "right"
  ) + 
  theme_classic() +
  ylim(0, 50)

```

Look at both survey years together we get the same picture, see fig. \@ref(fig:distr-plot).

```{r distr-plot, include=T, messages=F, fig.cap="Violin and overlapping boxplot of the costs from the survey, extreme outliers are not visible."}
stats_data <- DATA %>% 
  summarise(
    max    = format(round(max(costs),2), nsmall = 2),
    mean   = format(round(mean(costs),2), nsmall = 2),
    median = format(round(median(costs),2), nsmall = 2),
    min    = format(round(min(costs),2), nsmall = 2)
    )

text <- paste0(
  "Max.: ", stats_data$max, "\n",
  "Min.: ", stats_data$min, "\n",
  "Mean: ", stats_data$mean, "\n",
  "Median: ", stats_data$median, "\n"
  )

ggplot(DATA) +
  geom_violin(
    aes(x = "both survey years", y = costs), 
    fill=colorBlindBlack8[7],
    color=colorBlindBlack8[7]
    
    ) +
  geom_boxplot(
    aes(x = "both survey years", y = costs), 
    outlier.shape = NA, alpha=0.5, fill=colorBlindBlack8[5]
    ) +
  geom_segment(
    x = 1, y = 45,
    xend = 1, yend = 52,
    lineend = "round",
    linejoin = "round",
    size = 0.5, 
    arrow = arrow(length = unit(0.1, "inches"))
  ) + 
  xlab("") + ylab("Cost / Colony [Euro]") +
  annotate(
    "text",
    label = text,
    x = c(1.2), y = c(40),
    hjust = "right"
  ) + 
  theme_classic() +
  ylim(0, 50)
```



# Costs and Estimation

## Standard Costs

To calculate a standard value for data cleaning, we researched the official price in 2020 for several products and average usage amount by common beekeeping practices, see table \@ref(tab:standard-cost).

```{r standard-cost, include=T}
c <- "Our calculated estimates for treatment. Investments can be used long term (we calculate 10 years, eg. Hyperthermia) and are divided by the number of colonies. Material can also be used long term (~ 7 years, eg. Queen Cages) but needs to be bought for each colony. Consumables are used for each colony (eg. Formic Acid Long Term, 200ml)."
cn = c("Methode", "Investment", "Material", "Consumables")
knitr::kable(
  treatmentList[-1, c(3, 5:7)],
  booktabs = TRUE, row.names = FALSE, format="markdown",
  caption = c, col.names = cn
)
rm(c, cn)
```

## Compare Survey and Estimate

If we look at the results of the treatment costs in our survey and the with the estimates above, we can compare the results, see table \@ref(tab:summary). 

```{r summary, include=T}
c = "Table the total descriptive statistics for costs in our survey and estimates based on our standard cost estimates"

cs <- summary(DATA$costs)
es <- summary(DATA$t_estimated)

ct <- tibble(
  Type   = c("Survey", "Estimated"),
  min    = c(cs[1], es[1]),
  Q1     = c(cs[2], es[2]),
  Median = round(c(cs[3], es[3]), 2),
  Mean   = round(c(cs[4], es[4]), 2),
  Q3     = round(c(cs[5], es[5]), 2),
  Max    = c(cs[6], es[6])
)


knitr::kable(
  ct,
  booktabs = TRUE, row.names = FALSE,
  format = "markdown",
  caption = c
)

rm(c, cs, es, ct)

```

The most common treatment methods in our survey can be seen in table \@ref(tab:common).

```{r common, include=T}
# Get median number of colonies to calculate an estimate
m_colonies = median(DATA$hives_winter)

col <- DATA %>% 
    select(!!(paste0(treatmentList$ttotal, "12")))
# Get number of participates using the single treatment methods
sin <- col %>% 
    mutate(across(.cols = everything(), as.logical)) %>% colSums()
# get the average amount for number of months
nu <- col %>% na_if(0) %>% colMeans(na.rm=T)

common_single <- tibble(
  tname = treatmentList$tname,
  n = sin,
  p = round(sin*100/nrow(DATA),2),
  nu = round(nu, 2),
  est = round(treatmentList$investment / m_colonies + treatmentList$material + treatmentList$consumables*nu, 2)
) %>% arrange(desc(p))

c <- paste0("Most used Methods in the two survey years, average months indicating the average of months this methods was used. Estimated costs are calculated with ", m_colonies, " colonies, which represents the median number of colonies in our survey, and the average months of usage.")

cn = c("Method", "Total [n]", "Percent [%]", "Average Months[n]", "Estimated Costs")
knitr::kable(
  common_single,
  booktabs = TRUE, row.names = FALSE, format = "markdown",
  col.names = cn,
  caption = c
)
rm(cn, c, common_single, nu, sin, col, m_colonies)
```

The most common combinations, without Varroa Control and Drone Brood removal can be seen in table 
\@ref(tab:common-comb). The estimated costs are calculated for each beekeeper in the survey and then the average was taken as with the survey costs.

```{r common-comb, include=T, message=F}

DATA$t_desc_od <- str_replace(DATA$t_desc, "Drohnenbrutentnahme & ", "")
DATA$t_short_od <- str_replace(DATA$t_short, "Drohne & ", "")

d <- DATA %>% 
  group_by(t_short_od) %>% summarise(
    n     = n(),
    p     = round(n()*100/nrow(DATA),2),
    mc    = round(mean(costs), 2),
    medc  = round(median(costs), 2),
    me    = round(mean(t_estimated), 2),
    mede  = round(median(t_estimated), 2),
  ) %>% 
  filter(n >= 30) %>% arrange(desc(n))

c <- paste0("Most used combination with at least 30 participants, Mean and Median Costs from the survey and Estimated Costs in Euro.")

cn = c("Method", "Total [n]", "Percent [%]", "Cost Mean", "Cost Median", "Estimate Mean", "Estimate Median")

knitr::kable(
  d,
  booktabs = TRUE, row.names = FALSE,
  digits = 2,
  col.names = cn,
  caption = c,
)
rm(c, d)
```

## Linear Equation

To generate survey costs of treatments without combinations we used Linear Equation to solve for each single treatment. Did not work!

```{r linear-equation, include=T, warning = FALSE}

source("code-junks/LinearEquation.R", local = knitr::knit_global())
print(y)
rm(y)
```

## Bland-Altmann Plot

To check if our estimated in range with the survey, we use can use a bland-altmann plot, which compares the differences and shows if they are between our set confidence intervall (95%). For these plot we only use the mean prices with combinations of at least 15 beekeepers, see figure \@ref(fig:estimates-bland).

```{r estimates-bland, include=T, fig.cap="Bland-Altmann Plot with 95% Confidence Intervall, Mean difference between estimates and survey costs of the treatment combinations with at least 15 beekeepers." }
d <- DATA %>% 
  group_by(t_short_od) %>% summarise(
    n    = n(),
    p    = round(n()*100/nrow(DATA),2),
    mc   = round(mean(costs), 2),
    medc = round(median(costs), 2),
    me   = round(mean(t_estimated), 2),
    mede = round(median(t_estimated), 2),
  ) %>% 
  filter(n >= 15) %>% arrange(desc(n))

ba.stats <- bland.altman.stats(d$mc, d$me)

limit_y = round( ifelse( max(ba.stats$diffs) > (-1*min(ba.stats$diffs)), max(ba.stats$diffs), -1*min(ba.stats$diffs) ) + 0.5, digits = 1)

ggplot() +
  geom_point(aes(x = ba.stats$means, y = ba.stats$diffs, size = d$n)) +
  geom_abline(
    aes(
      intercept = ba.stats$lines, 
      colour = I(c(colorBlindBlack8[3], colorBlindBlack8[2], colorBlindBlack8[3])), 
      slope = c(rep(0, 3))),
    show.legend = F
    ) +
  geom_abline(
    aes(
      intercept = ba.stats$CI.lines, 
      color = I(c(rep(colorBlindBlack8[3], 2), rep(colorBlindBlack8[2], 2), rep(colorBlindBlack8[3], 2))),
      slope = c(rep(0, 6))
      ),
    linetype = "dashed",
    alpha = 0.5,
    show.legend = F
  ) +
  geom_hline(yintercept = 0, linetype = "dotted") +

  xlab("Means [Euro]") + ylab("Differences [Euro]") +
  labs(size = "Answers [n]") + 
  ylim(c( -1*limit_y, limit_y )) +
  theme_classic()

rm(d, ba.stats, limit_y)
```

## Conclusio

We can conclude that our estimates of treatment costs per colony are higher than calculated from the survey. Still the estimates are in range and not far off. 

# Operation Size

One question could be if bigger beekeeping operation spend less or more money on treatment. To test this we look at the cost distribution between different operation sizes, see fig. \@ref(fig:operation-size). The results indicate a bigger variance in the answers for the smaller hobby beekeepers, which could partly explained by the higher number of answers. The "1-20 Colonies" operations also have overall a higher mean and median cost answers. 

```{r operation-size, include=T, fig.cap="Mean and Median costs per colony in the survey for given Operation Size groups."}

K.SEQ <- c( seq( 0, 100, 20 ), Inf )
K.SEQ2 <- c( seq( 20, 120, 20 ), Inf )

V.LABEL <- paste(K.SEQ, K.SEQ2, sep = "-")
V.LABEL <- V.LABEL[1:6]
V.LABEL[6] <- "> 100"
V.LABEL[1] <- "1-20"

DATA$size_group <- cut( DATA$hives_winter, K.SEQ, labels=V.LABEL, include.lowest = TRUE, right = TRUE )

x <- DATA %>% group_by(size_group) %>% summarise(
  n       = n(),
  sm      = mean(costs),
  upper   = mean(costs)+sd(costs),
  lower   = mean(costs)-sd(costs),
  calc    = "Mean + Standard Deviation"
);

y <- DATA %>% group_by(size_group) %>% summarise(
  n       = n(),
  sm      = median(costs),
  upper   = quantile(costs)[4],
  lower   = quantile(costs)[2],
  calc    = "Median + 1 & 3 Quantile"
);

xy <- rbind(x, y)

ggplot(xy, aes(x = size_group, y = sm, ymin=lower, ymax=upper)) +
  geom_pointrange() + facet_wrap(~calc) +
  geom_text(aes(y=0, label = paste0("n=",n)), size=3) +
  xlab("Operation Size (Number of Colonies)") + ylab("Costs / Colony [Euro]") +
  theme_classic()
  
rm(xy, y, x, K.SEQ, K.SEQ2, V.LABEL)
```
# Estimated Economic Costs

## Generate Bootstrap CI

To generate a better estimate we use a confidence interval. The confidence interval is calculated with bootstrap method and 10000 replicas. With the bootstrap samples we calculate a confidence interval based on Bca.

The Distribution of the bootstrap mean and median can be seen in fig. \@ref(fig:boot-mean)-\@ref(fig:boot-median).

```{r}
# Generate Bootstrap Dataset
x <- boot::boot(DATA$costs, fBootMedian, R=10000); x
y <- boot::boot(DATA$costs, fBootMean, R=10000); y

fBootPlot <- function(x, t){
  p1 <- ggplot() + 
    geom_histogram(aes(x$t)) +
    geom_vline(xintercept=x$t0, color = colorBlindBlack8[2]) +
    geom_text(
      aes(x= x$t0+0.1, y = 1000, label = paste0(t, ": ", round(x$t0,2))),
      hjust="left",
      color = colorBlindBlack8[2]
      ) +
    theme_classic() + 
    xlab(paste("Cost -",t ,"[Euro]")) + ylab("Count [#]") + 
    ggtitle(paste(t,"- 10.000 Replicas"), subtitle = "Histogramm")
  
  p2 <- ggplot() + aes(sample=x$t) + 
    geom_qq() + geom_qq_line() +
    theme_classic() + ylab("Sample Quantiles (Costs)") + xlab("Theoretical Quantiles") +
    ggtitle("", subtitle = "QQ-Plot")
  
  return(p1 + p2)
}
```

```{r boot-mean, include=T, fig.cap="Boostrap Mean"}
p <- fBootPlot(y, "Mean")
p
```
```{r boot-median, include=T, fig.cap="Boostrap Median"}
p <- fBootPlot(y, "Median")
p
```

## Estimated Total Values in Austria





